{% extends "base.html" %}

{% block main_class %}{% endblock %}

{% block content %}
<div class="reader-layout">
    <!-- Toolbar flottante minimaliste -->
    <div class="reader-toolbar" id="reader-toolbar">
        <div class="toolbar-group">
            <button class="tool-btn" id="theme-toggle" title="Thème">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="5"></circle>
                    <line x1="12" y1="1" x2="12" y2="3"></line>
                    <line x1="12" y1="21" x2="12" y2="23"></line>
                    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                    <line x1="1" y1="12" x2="3" y2="12"></line>
                    <line x1="21" y1="12" x2="23" y2="12"></line>
                    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                </svg>
            </button>
            <button class="tool-btn" id="font-toggle" title="Police">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="4 7 4 4 20 4 20 7"></polyline>
                    <line x1="9" y1="20" x2="15" y2="20"></line>
                    <line x1="12" y1="4" x2="12" y2="20"></line>
                </svg>
            </button>
        </div>

        <div class="toolbar-divider"></div>

        <!-- Contrôles typographie -->
        <div class="toolbar-group typography-controls">
            <button class="tool-btn" id="font-decrease" title="Réduire">A-</button>
            <span class="font-size-display" id="font-size-display">14</span>
            <button class="tool-btn" id="font-increase" title="Agrandir">A+</button>
        </div>

        <div class="toolbar-divider"></div>

        <!-- Alignement -->
        <div class="toolbar-group">
            <button class="tool-btn" id="align-left" title="Gauche" onclick="setTextAlign('left')">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="12" x2="15" y2="12"></line>
                    <line x1="3" y1="18" x2="18" y2="18"></line>
                </svg>
            </button>
            <button class="tool-btn active" id="align-justify" title="Justifier" onclick="setTextAlign('justify')">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </button>
        </div>

        <div class="toolbar-divider"></div>

        <!-- Audio -->
        <div class="toolbar-group">
            <button class="tool-btn" id="tts-play" title="Lecture audio">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                    <polygon points="5 3 19 12 5 21 5 3"></polygon>
                </svg>
            </button>
            <button class="tool-btn" id="tts-pause" title="Pause" style="display:none;">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                    <rect x="6" y="4" width="4" height="16"></rect>
                    <rect x="14" y="4" width="4" height="16"></rect>
                </svg>
            </button>
            <button class="tool-btn" id="tts-stop" title="Stop">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                    <rect x="4" y="4" width="16" height="16" rx="2"></rect>
                </svg>
            </button>
            <span class="reading-time-badge" id="reading-time"></span>
        </div>

        <div class="toolbar-divider"></div>

        <!-- Actions -->
        <div class="toolbar-group">
            <button class="tool-btn" id="ruler-toggle" title="Guide de lecture">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="10" width="18" height="4" rx="1"></rect>
                </svg>
            </button>
            <button class="tool-btn" id="summary-toggle" title="Résumé AI">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 2L2 7l10 5 10-5-10-5z"></path>
                    <path d="M2 17l10 5 10-5"></path>
                    <path d="M2 12l10 5 10-5"></path>
                </svg>
            </button>
            <button class="tool-btn" id="braille-export-btn" title="Exporter en Braille">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="6" cy="6" r="2"></circle>
                    <circle cx="6" cy="12" r="2"></circle>
                    <circle cx="6" cy="18" r="2"></circle>
                    <circle cx="12" cy="6" r="2"></circle>
                    <circle cx="18" cy="12" r="2"></circle>
                    <circle cx="18" cy="18" r="2"></circle>
                </svg>
            </button>
            <button class="tool-btn" id="fullscreen-btn" title="Plein écran">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path
                        d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3">
                    </path>
                </svg>
            </button>
        </div>
    </div>

    <!-- Panneau de paramètres avancés (caché par défaut) -->
    <div class="settings-panel" id="settings-panel" style="display: none;">
        <div class="settings-content">
            <div class="setting-row">
                <label>Contraste</label>
                <input type="range" id="contrast-slider" min="0.5" max="1.5" step="0.1" value="1">
            </div>
            <div class="setting-row">
                <label>Espacement lettres</label>
                <input type="range" id="letter-spacing-slider" min="0" max="3" step="0.5" value="0">
            </div>
            <div class="setting-row">
                <label>Interligne</label>
                <input type="range" id="line-height-slider" min="1.4" max="2.4" step="0.1" value="1.8">
            </div>
        </div>
    </div>

    <!-- Zone de lecture principale -->
    <div class="reader-main" id="reader-container">
        <!-- Tags de mots-clés -->
        <div id="tags-container" class="tags-row"></div>

        <!-- Panneau résumé AI -->
        <div id="summary-panel" class="summary-card" style="display: none;">
            <div class="summary-header">
                <h3>✨ Résumé AI</h3>
                <button class="close-btn" id="close-summary">×</button>
            </div>
            <div id="summary-content" class="summary-body">Chargement...</div>
        </div>

        <!-- Contenu de la page avec redimensionnement -->
        <div class="page-content-wrapper">
            <div class="page-content-resizable" id="page-resizable">
                <div class="resize-handle resize-handle-left" id="resize-left"></div>
                <article id="page-content" class="page-content">
                    <div class="loading-spinner"></div>
                    <span class="loading-text">Chargement du document...</span>
                </article>
                <div class="resize-handle resize-handle-right" id="resize-right"></div>
            </div>
        </div>
        <div class="width-indicator" id="width-indicator"></div>

        <!-- Guide de lecture -->
        <div id="reading-ruler" class="reading-ruler" style="display: none;"></div>
    </div>

    <!-- Pagination fixe en bas -->
    <nav class="pagination-bar" id="pagination-controls" style="display: none;">
        <button class="page-btn" id="prev-page" disabled>
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="15 18 9 12 15 6"></polyline>
            </svg>
        </button>
        <span id="page-indicator" class="page-indicator">1 / ?</span>
        <button class="page-btn" id="next-page">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="9 18 15 12 9 6"></polyline>
            </svg>
        </button>
    </nav>
</div>

<script>
    const DOC_ID = "{{ document.id }}";
    const INITIAL_STATUS = "{{ document.status }}";
    const CACHE_KEY = `readzen_pages_${DOC_ID}`;
    const CACHE_EXPIRY_KEY = `readzen_pages_expiry_${DOC_ID}`;
    const CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 heures

    let pages = [];          // Contenu des pages (null = pas encore chargé)
    let pageCount = 0;       // Nombre total de pages
    let currentPage = 0;
    let loadingPage = null;  // Page en cours de chargement
    let currentFontSize = 14;
    let isPreloading = false; // Flag pour le préchargement en cascade

    // ============================================
    // CACHE MANAGEMENT - Persistance localStorage
    // ============================================

    function savePageToCache(pageNumber, content) {
        try {
            const cached = JSON.parse(localStorage.getItem(CACHE_KEY) || '{}');
            cached[pageNumber] = content;
            cached._pageCount = pageCount;
            localStorage.setItem(CACHE_KEY, JSON.stringify(cached));
            localStorage.setItem(CACHE_EXPIRY_KEY, Date.now() + CACHE_DURATION);
            console.log(`Page ${pageNumber} saved to localStorage cache`);
        } catch (e) {
            console.warn('Failed to save to localStorage:', e);
            // Si localStorage est plein, on nettoie le cache
            if (e.name === 'QuotaExceededError') {
                clearPageCache();
            }
        }
    }

    function loadPagesFromCache() {
        try {
            const expiry = localStorage.getItem(CACHE_EXPIRY_KEY);
            if (expiry && Date.now() > parseInt(expiry)) {
                console.log('Cache expired, clearing...');
                clearPageCache();
                return null;
            }

            const cached = localStorage.getItem(CACHE_KEY);
            if (cached) {
                const data = JSON.parse(cached);
                console.log('Loaded pages from localStorage cache:', Object.keys(data).filter(k => k !== '_pageCount').length, 'pages');
                return data;
            }
        } catch (e) {
            console.warn('Failed to load from localStorage:', e);
        }
        return null;
    }

    function clearPageCache() {
        localStorage.removeItem(CACHE_KEY);
        localStorage.removeItem(CACHE_EXPIRY_KEY);
        console.log('Page cache cleared');
    }

    // ============================================
    // CASCADE PRELOADING - Chargement en cascade
    // ============================================

    async function startCascadePreload() {
        if (isPreloading) {
            console.log('Cascade preload already in progress');
            return;
        }

        isPreloading = true;
        console.log('Starting cascade preload for all pages...');

        // Charger toutes les pages non chargées, une par une
        for (let i = 0; i < pageCount; i++) {
            if (!pages[i]) {
                console.log(`Cascade: loading page ${i}...`);
                await loadPage(i);

                // Petit délai pour ne pas surcharger le serveur
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }

        isPreloading = false;
        console.log('Cascade preload complete! All pages loaded.');
        updatePreloadStatus();
    }

    function updatePreloadStatus() {
        const loadedCount = pages.filter(p => p !== null && p !== undefined).length;
        const indicator = document.getElementById('preload-status');

        if (loadedCount === pageCount) {
            if (indicator) indicator.style.display = 'none';
            console.log(`All ${pageCount} pages are now cached locally`);
        } else if (indicator) {
            indicator.style.display = 'inline-flex';
            indicator.innerHTML = `<span class="preload-spinner"></span> ${loadedCount}/${pageCount}`;
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        accessibility.init();

        console.log("DOMContentLoaded - INITIAL_STATUS:", INITIAL_STATUS, "DOC_ID:", DOC_ID);

        if (INITIAL_STATUS === 'completed') {
            console.log("Document already completed, calling loadPages()");
            loadPages();
        } else {
            console.log("Document not completed, starting trackOCRStatus");
            trackOCRStatus(DOC_ID);
        }

        // Event Listeners for Pagination
        document.getElementById('prev-page').addEventListener('click', () => changePage(-1));
        document.getElementById('next-page').addEventListener('click', () => changePage(1));

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') changePage(-1);
            if (e.key === 'ArrowRight') changePage(1);
        });

        // Font size controls
        const fontDecrease = document.getElementById('font-decrease');
        const fontIncrease = document.getElementById('font-increase');
        const fontSizeDisplay = document.getElementById('font-size-display');

        if (fontDecrease && fontIncrease) {
            fontDecrease.addEventListener('click', () => {
                if (currentFontSize > 14) {
                    currentFontSize -= 2;
                    updateFontSize(currentFontSize);
                    fontSizeDisplay.textContent = currentFontSize;
                }
            });
            fontIncrease.addEventListener('click', () => {
                if (currentFontSize < 32) {
                    currentFontSize += 2;
                    updateFontSize(currentFontSize);
                    fontSizeDisplay.textContent = currentFontSize;
                }
            });
        }

        // Settings sliders
        const contrastSlider = document.getElementById('contrast-slider');
        const letterSpacingSlider = document.getElementById('letter-spacing-slider');
        const lineHeightSlider = document.getElementById('line-height-slider');

        if (contrastSlider) contrastSlider.addEventListener('input', (e) => updateContrast(e.target.value));
        if (letterSpacingSlider) letterSpacingSlider.addEventListener('input', (e) => updateLetterSpacing(e.target.value));
        if (lineHeightSlider) lineHeightSlider.addEventListener('input', (e) => updateLineHeight(e.target.value));

        // TTS Advanced Logic
        const ttsPlay = document.getElementById('tts-play');
        const ttsPause = document.getElementById('tts-pause');
        const ttsStop = document.getElementById('tts-stop');

        let utterance = null;

        function updateTTSUI(state) {
            if (state === 'playing') {
                ttsPlay.style.display = 'none';
                ttsPause.style.display = 'flex';
                ttsPlay.closest('.toolbar-group')?.classList.add('playing');
            } else if (state === 'paused') {
                ttsPlay.style.display = 'flex';
                ttsPause.style.display = 'none';
            } else {
                ttsPlay.style.display = 'flex';
                ttsPause.style.display = 'none';
                ttsPlay.closest('.toolbar-group')?.classList.remove('playing');
            }
        }

        if (ttsPlay && ttsPause && ttsStop) {
            ttsPlay.addEventListener('click', () => {
                const synth = window.speechSynthesis;

                if (synth.paused) {
                    synth.resume();
                    updateTTSUI('playing');
                    return;
                }

                if (synth.speaking) {
                    synth.cancel();
                }

                const wordSpans = Array.from(document.querySelectorAll('.read-word'));
                let ttsText = "";
                const wordMap = [];

                wordSpans.forEach(span => {
                    const word = span.innerText;
                    if (!word.trim()) return;

                    const start = ttsText.length;
                    ttsText += word + " ";
                    const end = ttsText.length - 1;

                    wordMap.push({ start, end, element: span });
                });

                if (!ttsText) {
                    const text = document.getElementById('page-content').innerText;
                    ttsText = text;
                }

                utterance = new SpeechSynthesisUtterance(ttsText);

                utterance.onboundary = (event) => {
                    if (event.name === 'word') {
                        const charIndex = event.charIndex;
                        const match = wordMap.find(w => charIndex >= w.start && charIndex < w.end + 2);

                        document.querySelectorAll('.word-active').forEach(el => el.classList.remove('word-active'));

                        if (match) {
                            match.element.classList.add('word-active');
                            const rect = match.element.getBoundingClientRect();
                            const wHeight = window.innerHeight;
                            if (rect.top < 80 || rect.bottom > wHeight - 80) {
                                match.element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }
                        }
                    }
                };

                utterance.onend = () => {
                    updateTTSUI('idle');
                    document.querySelectorAll('.word-active').forEach(el => el.classList.remove('word-active'));
                };
                utterance.onerror = () => {
                    updateTTSUI('idle');
                    document.querySelectorAll('.word-active').forEach(el => el.classList.remove('word-active'));
                };

                synth.speak(utterance);
                updateTTSUI('playing');
            });

            ttsPause.addEventListener('click', () => {
                window.speechSynthesis.pause();
                updateTTSUI('paused');
            });

            ttsStop.addEventListener('click', () => {
                window.speechSynthesis.cancel();
                updateTTSUI('idle');
                document.querySelectorAll('.word-active').forEach(el => el.classList.remove('word-active'));
            });

            window.addEventListener('beforeunload', () => {
                window.speechSynthesis.cancel();
            });
        }

        // Toolbar visibility on scroll
        let lastScrollY = window.scrollY;
        const toolbar = document.getElementById('reader-toolbar');

        window.addEventListener('scroll', () => {
            if (!toolbar) return;
            const currentScrollY = window.scrollY;

            if (currentScrollY > lastScrollY && currentScrollY > 150) {
                toolbar.classList.add('hidden');
            } else {
                toolbar.classList.remove('hidden');
            }
            lastScrollY = currentScrollY;
        }, { passive: true });

        // Fullscreen
        const fsBtn = document.getElementById('fullscreen-btn');
        if (fsBtn) {
            fsBtn.addEventListener('click', () => {
                const readerLayout = document.querySelector('.reader-layout');
                if (!document.fullscreenElement) {
                    readerLayout.requestFullscreen().then(() => {
                        fsBtn.classList.add('active');
                    }).catch(e => {
                        console.error(`Fullscreen error: ${e.message}`);
                    });
                } else {
                    document.exitFullscreen().then(() => {
                        fsBtn.classList.remove('active');
                    });
                }
            });

            document.addEventListener('fullscreenchange', () => {
                if (!document.fullscreenElement) {
                    fsBtn.classList.remove('active');
                }
            });
        }

        // Braille Export
        const brailleBtn = document.getElementById('braille-export-btn');
        if (brailleBtn) {
            brailleBtn.addEventListener('click', () => {
                const text = document.getElementById('page-content').innerText;
                const braille = accessibility.textToBraille(text);

                const blob = new Blob([braille], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `document_page${currentPage + 1}_braille.brf`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });
        }

        // Summary Toggle
        const summaryToggle = document.getElementById('summary-toggle');
        const summaryPanel = document.getElementById('summary-panel');
        const closeSummary = document.getElementById('close-summary');

        if (summaryToggle && summaryPanel) {
            summaryToggle.addEventListener('click', async () => {
                if (summaryPanel.style.display === 'none') {
                    summaryPanel.style.display = 'block';
                    summaryToggle.classList.add('active');
                    const body = document.getElementById('summary-content');
                    body.innerText = "Chargement...";

                    try {
                        const res = await fetch(`/api/documents/${DOC_ID}/summary`);
                        const data = await res.json();
                        const summaryText = data.summary;

                        if (summaryText) {
                            if (typeof marked !== 'undefined') {
                                body.innerHTML = marked.parse(summaryText);
                            } else {
                                body.innerText = summaryText;
                            }
                        } else {
                            body.innerText = "Résumé non disponible.";
                        }
                    } catch (e) {
                        console.error("Error fetching summary:", e);
                        body.innerText = "Erreur lors du chargement du résumé.";
                    }
                } else {
                    summaryPanel.style.display = 'none';
                    summaryToggle.classList.remove('active');
                }
            });

            if (closeSummary) {
                closeSummary.addEventListener('click', () => {
                    summaryPanel.style.display = 'none';
                    summaryToggle.classList.remove('active');
                });
            }
        }
    });

    async function loadPages() {
        try {
            console.log("Loading pages for document", DOC_ID);

            // 1. Vérifier le cache localStorage d'abord
            const cachedData = loadPagesFromCache();

            if (cachedData && cachedData._pageCount) {
                pageCount = cachedData._pageCount;
                pages = new Array(pageCount).fill(null);

                // Restaurer les pages depuis le cache
                let cachedCount = 0;
                for (let i = 0; i < pageCount; i++) {
                    if (cachedData[i]) {
                        pages[i] = cachedData[i];
                        cachedCount++;
                    }
                }

                console.log(`Restored ${cachedCount}/${pageCount} pages from cache`);

                // Charger la progression et afficher
                loadProgress();
                await renderPage();

                const controls = document.getElementById('pagination-controls');
                if (controls) controls.style.display = 'flex';

                // Continuer le préchargement des pages manquantes en cascade
                if (cachedCount < pageCount) {
                    startCascadePreload();
                } else {
                    updatePreloadStatus();
                }
                return;
            }

            // 2. Sinon, charger depuis l'API
            const res = await fetch(`/api/documents/${DOC_ID}/text`);
            const data = await res.json();

            console.log("API response:", data);

            // Déterminer les pages et leur nombre
            if (data.pages && data.pages.length > 0) {
                pages = data.pages;
                pageCount = data.page_count || data.pages.length;

                // Sauvegarder toutes les pages reçues dans le cache
                for (let i = 0; i < pages.length; i++) {
                    if (pages[i]) {
                        savePageToCache(i, pages[i]);
                    }
                }
            } else if (data.text) {
                pages = [data.text];
                pageCount = 1;
                savePageToCache(0, data.text);
            } else {
                pages = ["No text content found."];
                pageCount = 1;
            }

            console.log("Page count:", pageCount);
            console.log("Pages loaded:", pages.length);

            // Attempt resume from saved progress
            loadProgress();

            await renderPage();

            const controls = document.getElementById('pagination-controls');
            if (controls) controls.style.display = 'flex';

            // Démarrer le préchargement en cascade pour toutes les pages
            if (pageCount > 1) {
                startCascadePreload();
            }
        } catch (e) {
            console.error("Error in loadPages:", e);
            const contentDiv = document.getElementById('page-content');
            if (contentDiv) contentDiv.innerText = "Error loading text.";
        }
    }

    async function loadPage(pageNumber) {
        /**
         * Charge une page spécifique depuis l'API.
         * Retourne le contenu HTML de la page.
         */
        console.log(`loadPage called for page ${pageNumber}`);

        if (pageNumber < 0 || pageNumber >= pageCount) {
            console.log(`Page ${pageNumber} out of range (0-${pageCount - 1})`);
            return null;
        }

        // Si déjà chargée, retourner le contenu
        if (pages[pageNumber]) {
            console.log(`Page ${pageNumber} already loaded, returning cached content`);
            return pages[pageNumber];
        }

        // Éviter les chargements en double
        if (loadingPage === pageNumber) {
            console.log(`Page ${pageNumber} is already being loaded, waiting...`);
            // Attendre que le chargement en cours soit terminé
            while (loadingPage === pageNumber) {
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            return pages[pageNumber];
        }

        loadingPage = pageNumber;

        try {
            console.log(`Fetching page ${pageNumber} from API...`);
            const res = await fetch(`/api/documents/${DOC_ID}/page/${pageNumber}`);

            if (!res.ok) {
                const errorText = await res.text();
                console.error(`Failed to load page ${pageNumber}: ${res.status} - ${errorText}`);
                throw new Error(`Failed to load page ${pageNumber}`);
            }

            const data = await res.json();
            pages[pageNumber] = data.content;

            // Sauvegarder dans le cache localStorage
            savePageToCache(pageNumber, data.content);

            console.log(`Page ${pageNumber} loaded successfully (${data.content?.length || 0} chars)`);

            // Mettre à jour l'indicateur de préchargement
            updatePreloadStatus();

            return data.content;
        } catch (e) {
            console.error(`Error loading page ${pageNumber}:`, e);
            return null;
        } finally {
            loadingPage = null;
        }
    }

    function preloadPage(pageNumber) {
        /**
         * Précharge une page en arrière-plan sans bloquer.
         * Note: Utilisé principalement pour un chargement prioritaire
         */
        console.log(`preloadPage called for page ${pageNumber}`);
        if (pageNumber < 0 || pageNumber >= pageCount) {
            console.log(`Cannot preload page ${pageNumber}: out of range`);
            return;
        }
        if (pages[pageNumber]) {
            console.log(`Page ${pageNumber} already loaded, no need to preload`);
            return;
        }

        // Charger silencieusement (sans await)
        console.log(`Starting background load for page ${pageNumber}`);
        loadPage(pageNumber);
    }

    async function renderPage() {
        console.log(`renderPage called, currentPage=${currentPage}, pageCount=${pageCount}`);

        if (pageCount === 0) {
            console.log("No pages to render");
            return;
        }

        const contentDiv = document.getElementById('page-content');
        let pageText = pages[currentPage];

        console.log(`Current page ${currentPage} content: ${pageText ? 'loaded' : 'not loaded'}`);

        // Si la page n'est pas encore chargée, la charger
        if (!pageText) {
            contentDiv.innerHTML = '<div class="loading-spinner"></div> Chargement de la page...';
            console.log(`Loading page ${currentPage}...`);
            pageText = await loadPage(currentPage);

            if (!pageText) {
                contentDiv.innerText = "Erreur lors du chargement de la page.";
                return;
            }
        }

        // Passer le texte HTML à colorizeText
        accessibility.colorizeText(pageText);

        // Update Controls
        const ind = document.getElementById('page-indicator');
        if (ind) ind.innerText = `Page ${currentPage + 1} / ${pageCount}`;

        const prev = document.getElementById('prev-page');
        if (prev) prev.disabled = currentPage === 0;

        const next = document.getElementById('next-page');
        if (next) next.disabled = currentPage >= pageCount - 1;

        console.log(`Navigation: prev disabled=${currentPage === 0}, next disabled=${currentPage >= pageCount - 1}`);

        // Reading Time Update
        calculateReadingTime(pageText);

        // Extract keywords for tags
        extractKeywords(pageText);

        // Save reading progress
        saveProgress();

        // Scroll to top
        window.scrollTo(0, 0);

        // En mode plein écran, scroller le conteneur
        const readerLayout = document.querySelector('.reader-layout');
        if (document.fullscreenElement && readerLayout) {
            readerLayout.scrollTop = 0;
        }

        // Re-apply styles that might be reset by innerHTML replacement
        const savedLine = localStorage.getItem('readzen_line_height');
        if (savedLine) updateLineHeight(savedLine);
        const savedSpacing = localStorage.getItem('readzen_letter_spacing');
        if (savedSpacing) updateLetterSpacing(savedSpacing);
        const savedAlign = localStorage.getItem('readzen_text_align');
        if (savedAlign) setTextAlign(savedAlign);
    }

    async function changePage(delta) {
        console.log(`changePage called with delta=${delta}, currentPage=${currentPage}, pageCount=${pageCount}`);
        const newPage = currentPage + delta;
        if (newPage >= 0 && newPage < pageCount) {
            console.log(`Changing to page ${newPage}`);
            currentPage = newPage;
            await renderPage();
        } else {
            console.log(`Cannot change to page ${newPage}: out of range`);
        }
    }

    async function trackOCRStatus(docId) {
        const contentDiv = document.getElementById('page-content');
        if (!contentDiv) return;

        console.log("Starting OCR tracking for doc " + docId);

        // Afficher un loader élégant
        contentDiv.innerHTML = `
            <div class="ocr-loading">
                <div class="ocr-spinner"></div>
                <h3 class="ocr-title">Analyse du document en cours</h3>
                <p class="ocr-subtitle">Extraction et mise en forme du texte...</p>
                <div class="ocr-progress">
                    <div class="ocr-progress-bar"></div>
                </div>
            </div>
        `;

        const poll = async () => {
            try {
                // Cache busting query param
                const res = await fetch(`/api/documents/${docId}?t=${Date.now()}`);
                if (!res.ok) throw new Error("API Error");

                const data = await res.json();

                if (data.status === 'completed') {
                    loadPages();
                } else if (data.status === 'failed') {
                    contentDiv.innerHTML = `
                        <div class="ocr-loading ocr-error">
                            <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="10"></circle>
                                <line x1="15" y1="9" x2="9" y2="15"></line>
                                <line x1="9" y1="9" x2="15" y2="15"></line>
                            </svg>
                            <h3 class="ocr-title">Échec du traitement</h3>
                            <p class="ocr-subtitle">Impossible de traiter ce document. Essayez un autre PDF.</p>
                        </div>
                    `;
                } else {
                    // Continue polling if pending/processing
                    setTimeout(poll, 2000);
                }
            } catch (e) {
                console.error(e);
                // Retry slower on error
                setTimeout(poll, 5000);
            }
        };

        // Start polling
        poll();
    }

    function calculateReadingTime(text) {
        if (!text) return;
        const words = text.trim().split(/\s+/).length;
        const wpm = 200;
        const minutes = Math.ceil(words / wpm);
        const readingTimeSpan = document.getElementById('reading-time');
        if (readingTimeSpan) {
            readingTimeSpan.innerText = `${minutes} min`;
        }
    }

    // --- New Features (Zoom, Tags, Resume) ---

    function updateContrast(value) {
        const content = document.getElementById('page-content');
        if (content) {
            content.style.filter = `contrast(${value})`;
        }
    }

    function updateFontSize(size) {
        const content = document.getElementById('page-content');
        if (content) {
            content.style.fontSize = `${size}px`;
            // Save preference
            localStorage.setItem('readzen_font_size', size);
        }
    }

    function updateLetterSpacing(val) {
        const content = document.getElementById('page-content');
        if (content) {
            content.style.letterSpacing = `${val}px`;
            localStorage.setItem('readzen_letter_spacing', val);
        }
    }

    function updateLineHeight(val) {
        const content = document.getElementById('page-content');
        if (content) {
            content.style.lineHeight = val;
            const paragraphs = content.querySelectorAll('p');
            paragraphs.forEach(p => p.style.lineHeight = val); // Force on P tags to override CSS
            localStorage.setItem('readzen_line_height', val);
        }
    }

    function setTextAlign(align) {
        const content = document.getElementById('page-content');
        if (content) {
            // Appliquer l'alignement à tous les paragraphes et éléments de texte
            const elements = content.querySelectorAll('p, div, h1, h2, h3, h4, h5, h6');
            elements.forEach(el => {
                el.style.textAlign = align;
            });
            // Aussi sur le conteneur principal
            content.style.textAlign = align;

            // Mettre à jour les boutons actifs
            document.querySelectorAll('#align-left, #align-center, #align-justify, #align-right').forEach(btn => {
                btn.classList.remove('active');
            });
            const activeBtn = document.getElementById(`align-${align}`);
            if (activeBtn) activeBtn.classList.add('active');

            // Sauvegarder la préférence
            localStorage.setItem('readzen_text_align', align);
        }
    }

    function extractKeywords(text) {
        // Simple stop-word filter (French)
        const stopWords = new Set(['le', 'la', 'les', 'de', 'du', 'des', 'un', 'une', 'et', 'à', 'en', 'il', 'elle', 'que', 'qui', 'ce', 'se', 'dans', 'pour', 'sur', 'au', 'aux', 'ne', 'pas', 'plus', 'par', 'avec', 'son', 'sa', 'ses', 'est', 'sont']);
        const words = text.toLowerCase().match(/\b[a-zà-ÿ]{4,}\b/g) || [];

        const counts = {};
        words.forEach(w => {
            if (!stopWords.has(w)) {
                counts[w] = (counts[w] || 0) + 1;
            }
        });

        // Top 5
        const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]).slice(0, 5);

        const container = document.getElementById('tags-container');
        if (container) {
            container.innerHTML = sorted.map(([word, count]) =>
                `<span class="tag-chip" style="background: rgba(0,0,0,0.05); padding: 4px 8px; border-radius: 4px; font-size: 0.8rem;">#${word}</span>`
            ).join('');
        }
    }

    function saveProgress() {
        const progress = {
            docId: DOC_ID,
            page: currentPage,
            timestamp: Date.now()
        };
        localStorage.setItem(`progress_${DOC_ID}`, JSON.stringify(progress));
    }

    function loadProgress() {
        const saved = localStorage.getItem(`progress_${DOC_ID}`);
        if (saved) {
            const data = JSON.parse(saved);
            // Verify timestamp if needed, for now just load page
            if (data.page && data.page < pageCount) {
                currentPage = data.page;
                console.log("Resuming at page " + currentPage);
            }
        }

        // Restore font size
        const savedSize = localStorage.getItem('readzen_font_size');
        if (savedSize) {
            const slider = document.getElementById('font-size-slider');
            if (slider) slider.value = savedSize;
            updateFontSize(savedSize);
        }

        // Restore Letter Spacing
        const savedSpacing = localStorage.getItem('readzen_letter_spacing');
        if (savedSpacing) {
            const slider = document.getElementById('letter-spacing-slider');
            if (slider) slider.value = savedSpacing;
            updateLetterSpacing(savedSpacing);
        }

        // Restore Line Height
        const savedLine = localStorage.getItem('readzen_line_height');
        if (savedLine) {
            const slider = document.getElementById('line-height-slider');
            if (slider) slider.value = savedLine;
            updateLineHeight(savedLine);
        }

        // Restore Text Alignment
        const savedAlign = localStorage.getItem('readzen_text_align');
        if (savedAlign) {
            setTextAlign(savedAlign);
        }
    }

    // ============================================
    // PAGE WIDTH RESIZING - Redimensionnement de la largeur
    // ============================================

    function initPageResizing() {
        const resizable = document.getElementById('page-resizable');
        const resizeLeft = document.getElementById('resize-left');
        const resizeRight = document.getElementById('resize-right');
        const widthIndicator = document.getElementById('width-indicator');

        if (!resizable || !resizeLeft || !resizeRight) return;

        let isResizing = false;
        let startX = 0;
        let startWidth = 0;
        let currentHandle = null;

        // Restore saved width from localStorage
        const savedWidth = localStorage.getItem('readzen_page_width');
        if (savedWidth) {
            resizable.style.width = savedWidth + 'px';
        }

        function showWidthIndicator(width) {
            widthIndicator.textContent = `${Math.round(width)}px`;
            widthIndicator.classList.add('visible');
        }

        function hideWidthIndicator() {
            widthIndicator.classList.remove('visible');
        }

        function startResize(e, handle) {
            e.preventDefault();
            isResizing = true;
            currentHandle = handle;
            startX = e.clientX || e.touches?.[0]?.clientX || 0;
            startWidth = resizable.offsetWidth;

            handle.classList.add('active');
            document.body.style.cursor = 'ew-resize';
            document.body.style.userSelect = 'none';

            showWidthIndicator(startWidth);
        }

        function doResize(e) {
            if (!isResizing) return;

            const clientX = e.clientX || e.touches?.[0]?.clientX || 0;
            const deltaX = clientX - startX;

            let newWidth;
            if (currentHandle === resizeLeft) {
                // Poignée gauche : inverser le delta
                newWidth = startWidth - (deltaX * 2);
            } else {
                // Poignée droite : delta normal
                newWidth = startWidth + (deltaX * 2);
            }

            // Limites min/max
            const minWidth = 320;
            const maxWidth = window.innerWidth - 48;
            newWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));

            resizable.style.width = newWidth + 'px';
            showWidthIndicator(newWidth);
        }

        function stopResize() {
            if (!isResizing) return;

            isResizing = false;

            // Save width to localStorage
            const currentWidth = resizable.offsetWidth;
            localStorage.setItem('readzen_page_width', currentWidth);

            if (currentHandle) {
                currentHandle.classList.remove('active');
            }
            currentHandle = null;
            document.body.style.cursor = '';
            document.body.style.userSelect = '';

            hideWidthIndicator();
        }

        // Mouse events
        resizeLeft.addEventListener('mousedown', (e) => startResize(e, resizeLeft));
        resizeRight.addEventListener('mousedown', (e) => startResize(e, resizeRight));

        document.addEventListener('mousemove', doResize);
        document.addEventListener('mouseup', stopResize);

        // Touch events for mobile
        resizeLeft.addEventListener('touchstart', (e) => startResize(e, resizeLeft), { passive: false });
        resizeRight.addEventListener('touchstart', (e) => startResize(e, resizeRight), { passive: false });

        document.addEventListener('touchmove', doResize, { passive: false });
        document.addEventListener('touchend', stopResize);

        // Double-click to reset to default width
        resizeLeft.addEventListener('dblclick', resetWidth);
        resizeRight.addEventListener('dblclick', resetWidth);

        function resetWidth() {
            resizable.style.width = '720px';
            localStorage.setItem('readzen_page_width', 720);

            // Show feedback
            showWidthIndicator(720);
            setTimeout(hideWidthIndicator, 800);
        }
    }

    // Initialize resize functionality after DOM is ready
    document.addEventListener('DOMContentLoaded', initPageResizing);

</script>
{% endblock %}