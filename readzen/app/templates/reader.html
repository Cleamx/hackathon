{% extends "base.html" %}

{% block content %}
<div class="reader-layout">
    <div id="tags-container" class="tags-row">
        <!-- Tags injected here -->
    </div>

    <div class="toolbar">
        <div class="dropdown-container">
            <button class="btn" id="theme-toggle" title="Changer de th√®me">Theme ‚ñæ</button>
            <div class="dropdown-menu">
                <div class="dropdown-item">
                    <span style="font-size: 0.8rem; margin-bottom: 4px; display: block;">Contraste</span>
                    <input type="range" id="contrast-slider" min="0.5" max="1.5" step="0.1" value="1"
                        onchange="updateContrast(this.value)" title="Ajuster le contraste">
                </div>
            </div>
        </div>
        <button class="btn" id="font-toggle" title="Changer de police">Police</button>

        <div class="slider-group">
            <span style="font-size: 0.8rem">A</span>
            <input type="range" id="font-size-slider" min="16" max="32" value="20" onchange="updateFontSize(this.value)"
                title="Taille de la police">
            <span style="font-size: 1.2rem">A</span>
        </div>

        <div class="slider-group" style="border-left: 1px solid var(--color-border); padding-left: 10px;">
            <span style="font-size: 0.8rem">‚Üî</span>
            <input type="range" id="letter-spacing-slider" min="0" max="3" step="0.5" value="0"
                onchange="updateLetterSpacing(this.value)" title="Espacement caract√®res">

            <span style="font-size: 0.8rem; margin-left: 8px;">‚Üï</span>
            <input type="range" id="line-height-slider" min="1.4" max="2.4" step="0.1" value="1.8"
                onchange="updateLineHeight(this.value)" title="Interligne">
        </div>

        <div style="display: flex; flex-direction: column; align-items: center;">
            <div class="slider-group" style="padding: 4px; gap: 0;">
                <button class="btn-icon" id="tts-play" title="Lecture">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"
                        stroke-linecap="round" stroke-linejoin="round">
                        <polygon points="5 3 19 12 5 21 5 3"></polygon>
                    </svg>
                </button>
                <button class="btn-icon" id="tts-pause" title="Pause" style="display:none;">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"
                        stroke-linecap="round" stroke-linejoin="round">
                        <rect x="6" y="4" width="4" height="16"></rect>
                        <rect x="14" y="4" width="4" height="16"></rect>
                    </svg>
                </button>
                <button class="btn-icon" id="tts-stop" title="Stop">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"
                        stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                    </svg>
                </button>
            </div>
            <span id="reading-time"
                style="font-size: 0.65rem; color: var(--color-text-muted); margin-top: 2px; font-weight: 600;"></span>
        </div>
        <button class="btn" id="ruler-toggle" title="Guide de lecture">üìè</button>
        <button class="btn" id="fullscreen-btn" title="Mode Zen (Plein √âcran)">‚õ∂</button>
    </div>

    <div id="reader-container" style="position: relative;">
        <div id="page-content" class="page-frame">
            <div class="loading-spinner"></div>
            Chargement du document...
        </div>
        <div id="reading-ruler" class="reading-ruler" style="display: none;"></div>

        <div class="pagination-controls" id="pagination-controls"
            style="display: none; justify-content: center; gap: 20px; align-items: center; margin-bottom: 40px;">
            <button class="btn" id="prev-page" disabled>Pr√©c√©dent</button>
            <span id="page-indicator" style="font-variant-numeric: tabular-nums;">Page 1 / ?</span>
            <button class="btn btn-primary" id="next-page">Suivant</button>
        </div>
    </div>
</div>

<script>
    const DOC_ID = "{{ document.id }}";
    const INITIAL_STATUS = "{{ document.status }}";

    let pages = [];
    let currentPage = 0;

    document.addEventListener('DOMContentLoaded', () => {
        accessibility.init();

        if (INITIAL_STATUS === 'completed') {
            loadPages();
        } else {
            trackOCRStatus(DOC_ID);
        }

        // Event Listeners for Pagination
        document.getElementById('prev-page').addEventListener('click', () => changePage(-1));
        document.getElementById('next-page').addEventListener('click', () => changePage(1));

        // TTS Advanced Logic
        const ttsPlay = document.getElementById('tts-play');
        const ttsPause = document.getElementById('tts-pause');
        const ttsStop = document.getElementById('tts-stop');

        let utterance = null;

        function updateTTSUI(state) {
            // state: 'idle', 'playing', 'paused'
            if (state === 'playing') {
                ttsPlay.style.display = 'none';
                ttsPause.style.display = 'inline-flex';
            } else if (state === 'paused') {
                ttsPlay.style.display = 'inline-flex';
                ttsPause.style.display = 'none';
            } else { // idle
                ttsPlay.style.display = 'inline-flex';
                ttsPause.style.display = 'none';
            }
        }

        if (ttsPlay && ttsPause && ttsStop) {
            ttsPlay.addEventListener('click', () => {
                const synth = window.speechSynthesis;

                if (synth.paused) {
                    synth.resume();
                    updateTTSUI('playing');
                    return;
                }

                if (synth.speaking) {
                    synth.cancel();
                }

                // --- Enhanced TTS with Visual Guide ---
                // 1. Get all word spans
                const wordSpans = Array.from(document.querySelectorAll('.read-word'));

                // 2. Construct text and map ranges
                let ttsText = "";
                const wordMap = [];

                wordSpans.forEach(span => {
                    const word = span.innerText; // Use innerText to get clean text
                    if (!word.trim()) return; // Skip empty

                    const start = ttsText.length;
                    ttsText += word + " "; // Add space
                    const end = ttsText.length - 1; // Exclude space

                    wordMap.push({
                        start: start,
                        end: end,
                        element: span
                    });
                });

                if (!ttsText) {
                    const text = document.getElementById('page-content').innerText;
                    ttsText = text; // Fallback if no spans found
                }

                utterance = new SpeechSynthesisUtterance(ttsText);

                // 3. Highlight Logic
                utterance.onboundary = (event) => {
                    if (event.name === 'word') {
                        const charIndex = event.charIndex;

                        // Find the word that contains this charIndex
                        // Since 'word' event might trigger on punctuation, we search close matches
                        const match = wordMap.find(w => charIndex >= w.start && charIndex < w.end + 2);
                        // +2 tolerance for spaces/punctuation

                        // Clear previous active
                        document.querySelectorAll('.word-active').forEach(el => el.classList.remove('word-active'));

                        if (match) {
                            match.element.classList.add('word-active');

                            // Auto-scroll to keep meaningful visual context
                            // Only scroll if element is confusingly off-screen
                            const rect = match.element.getBoundingClientRect();
                            const wHeight = window.innerHeight;
                            if (rect.top < 80 || rect.bottom > wHeight - 80) {
                                match.element.scrollIntoView({
                                    behavior: 'smooth',
                                    block: 'center'
                                });
                            }
                        }
                    }
                };

                utterance.onend = () => {
                    updateTTSUI('idle');
                    document.querySelectorAll('.word-active').forEach(el => el.classList.remove('word-active'));
                };
                utterance.onerror = () => {
                    updateTTSUI('idle');
                    document.querySelectorAll('.word-active').forEach(el => el.classList.remove('word-active'));
                };

                synth.speak(utterance);
                updateTTSUI('playing');
            });

            ttsPause.addEventListener('click', () => {
                window.speechSynthesis.pause();
                updateTTSUI('paused');
            });

            ttsStop.addEventListener('click', () => {
                window.speechSynthesis.cancel();
                updateTTSUI('idle');
                document.querySelectorAll('.word-active').forEach(el => el.classList.remove('word-active'));
            });

            // Safety: cancel on page unload
            window.addEventListener('beforeunload', () => {
                window.speechSynthesis.cancel();
            });
        }

        // Scroll Aware Toolbar
        let lastScrollY = window.scrollY;
        const toolbar = document.querySelector('.toolbar');

        window.addEventListener('scroll', () => {
            if (!toolbar) return;

            const currentScrollY = window.scrollY;

            // Should usually hide when going down, show when going up.
            // But we might want to keep it shown at the very top.
            if (currentScrollY > lastScrollY && currentScrollY > 100) {
                // Scrolling DOWN
                toolbar.classList.add('hidden-scroll');
            } else {
                // Scrolling UP or at top
                toolbar.classList.remove('hidden-scroll');
            }

            lastScrollY = currentScrollY;
        }, { passive: true });

        // Fullscreen
        const fsBtn = document.getElementById('fullscreen-btn');
        if (fsBtn) {
            fsBtn.addEventListener('click', () => {
                const container = document.getElementById('reader-container');
                if (!document.fullscreenElement) {
                    container.requestFullscreen().catch(e => {
                        console.error(`Error attempting to enable fullscreen: ${e.message}`);
                    });
                } else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    }
                }
            });
        }
    });

    async function loadPages() {
        try {
            const res = await fetch(`/api/documents/${DOC_ID}/text`);
            const data = await res.json();

            if (data.pages && data.pages.length > 0) {
                pages = data.pages;
            } else if (data.text) {
                pages = [data.text];
            } else {
                pages = ["No text content found."];
            }

            currentPage = 0;
            renderPage();
            const controls = document.getElementById('pagination-controls');
            if (controls) controls.style.display = 'flex';
        } catch (e) {
            console.error(e);
            const contentDiv = document.getElementById('page-content');
            if (contentDiv) contentDiv.innerText = "Error loading text.";
        }
    }

    function renderPage() {
        if (pages.length === 0) return;

        const contentDiv = document.getElementById('page-content');
        if (contentDiv) contentDiv.innerText = pages[currentPage];

        // Update Accessibility (Coloring)
        accessibility.colorizeText();

        // Update Controls
        const ind = document.getElementById('page-indicator');
        if (ind) ind.innerText = `Page ${currentPage + 1} / ${pages.length}`;

        const prev = document.getElementById('prev-page');
        if (prev) prev.disabled = currentPage === 0;

        const next = document.getElementById('next-page');
        if (next) next.disabled = currentPage === pages.length - 1;

        // Reading Time Update
        calculateReadingTime(pages[currentPage]);

        // Scroll to top
        window.scrollTo(0, 0);
    }

    function changePage(delta) {
        const newPage = currentPage + delta;
        if (newPage >= 0 && newPage < pages.length) {
            currentPage = newPage;
            renderPage();
        }
    }

    async function trackOCRStatus(docId) {
        const contentDiv = document.getElementById('page-content');
        if (!contentDiv) return;

        console.log("Starting OCR tracking for doc " + docId);

        const poll = async () => {
            try {
                // Cache busting query param
                const res = await fetch(`/api/documents/${docId}?t=${Date.now()}`);
                if (!res.ok) throw new Error("API Error");

                const data = await res.json();

                // Show actual status for debugging
                contentDiv.innerText = `Processing OCR... Status: ${data.status} (v3)`;

                if (data.status === 'completed') {
                    loadPages();
                } else if (data.status === 'failed') {
                    contentDiv.innerText = "Processing failed. Please try a different PDF.";
                } else {
                    // Continue polling if pending/processing
                    setTimeout(poll, 2000);
                }
            } catch (e) {
                console.error(e);
                contentDiv.innerText = `Error: ${e.message}. Retrying...`;
                // Retry slower on error
                setTimeout(poll, 5000);
            }
        };

        // Start polling
        poll();
    }

    function calculateReadingTime(text) {
        if (!text) return;
        const words = text.trim().split(/\s+/).length;
        const wpm = 200;
        const minutes = Math.ceil(words / wpm);
        const readingTimeSpan = document.getElementById('reading-time');
        if (readingTimeSpan) {
            readingTimeSpan.innerText = `${minutes} min`;
        }
    }

    // --- New Features (Zoom, Tags, Resume) ---

    function updateContrast(value) {
        const content = document.getElementById('page-content');
        if (content) {
            content.style.filter = `contrast(${value})`;
        }
    }

    function updateFontSize(size) {
        const content = document.getElementById('page-content');
        if (content) {
            content.style.fontSize = `${size}px`;
            // Save preference
            localStorage.setItem('readzen_font_size', size);
        }
    }

    function updateLetterSpacing(val) {
        const content = document.getElementById('page-content');
        if (content) {
            content.style.letterSpacing = `${val}px`;
            localStorage.setItem('readzen_letter_spacing', val);
        }
    }

    function updateLineHeight(val) {
        const content = document.getElementById('page-content');
        if (content) {
            content.style.lineHeight = val;
            const paragraphs = content.querySelectorAll('p');
            paragraphs.forEach(p => p.style.lineHeight = val); // Force on P tags to override CSS
            localStorage.setItem('readzen_line_height', val);
        }
    }

    function extractKeywords(text) {
        // Simple stop-word filter (French)
        const stopWords = new Set(['le', 'la', 'les', 'de', 'du', 'des', 'un', 'une', 'et', '√†', 'en', 'il', 'elle', 'que', 'qui', 'ce', 'se', 'dans', 'pour', 'sur', 'au', 'aux', 'ne', 'pas', 'plus', 'par', 'avec', 'son', 'sa', 'ses', 'est', 'sont']);
        const words = text.toLowerCase().match(/\b[a-z√†-√ø]{4,}\b/g) || [];

        const counts = {};
        words.forEach(w => {
            if (!stopWords.has(w)) {
                counts[w] = (counts[w] || 0) + 1;
            }
        });

        // Top 5
        const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]).slice(0, 5);

        const container = document.getElementById('tags-container');
        if (container) {
            container.innerHTML = sorted.map(([word, count]) =>
                `<span class="tag-chip" style="background: rgba(0,0,0,0.05); padding: 4px 8px; border-radius: 4px; font-size: 0.8rem;">#${word}</span>`
            ).join('');
        }
    }

    function saveProgress() {
        const progress = {
            docId: DOC_ID,
            page: currentPage,
            timestamp: Date.now()
        };
        localStorage.setItem(`progress_${DOC_ID}`, JSON.stringify(progress));
    }

    function loadProgress() {
        const saved = localStorage.getItem(`progress_${DOC_ID}`);
        if (saved) {
            const data = JSON.parse(saved);
            // Verify timestamp if needed, for now just load page
            if (data.page && data.page < pages.length) {
                currentPage = data.page;
                console.log("Resuming at page " + currentPage);
            }
        }

        // Restore font size
        const savedSize = localStorage.getItem('readzen_font_size');
        if (savedSize) {
            const slider = document.getElementById('font-size-slider');
            if (slider) slider.value = savedSize;
            updateFontSize(savedSize);
        }

        // Restore Letter Spacing
        const savedSpacing = localStorage.getItem('readzen_letter_spacing');
        if (savedSpacing) {
            const slider = document.getElementById('letter-spacing-slider');
            if (slider) slider.value = savedSpacing;
            updateLetterSpacing(savedSpacing);
        }

        // Restore Line Height
        const savedLine = localStorage.getItem('readzen_line_height');
        if (savedLine) {
            const slider = document.getElementById('line-height-slider');
            if (slider) slider.value = savedLine;
            updateLineHeight(savedLine);
        }
    }

    // Hook into renderPage for Keywords and Save Logic
    const oldRender = renderPage;
    renderPage = function () {
        if (pages.length === 0) return;

        // Call original
        const contentDiv = document.getElementById('page-content');
        // We don't need to set innerText since colorizeText will overwrite innerHTML
        // But we MUST pass the text to colorizeText to update its cache
        const text = pages[currentPage];
        accessibility.colorizeText(text);

        const ind = document.getElementById('page-indicator');
        if (ind) ind.innerText = `Page ${currentPage + 1} / ${pages.length}`;
        const prev = document.getElementById('prev-page');
        if (prev) prev.disabled = currentPage === 0;
        const next = document.getElementById('next-page');
        if (next) next.disabled = currentPage === pages.length - 1;
        calculateReadingTime(pages[currentPage]);
        window.scrollTo(0, 0);

        // New Logic
        extractKeywords(pages[currentPage]);
        saveProgress();

        // Re-apply styles that might be reset by InnerText/HTML replacement
        const savedLine = localStorage.getItem('readzen_line_height');
        if (savedLine) updateLineHeight(savedLine);
        const savedSpacing = localStorage.getItem('readzen_letter_spacing');
        if (savedSpacing) updateLetterSpacing(savedSpacing);
    };

    // Override loadPages to trigger resume loading
    const oldLoad = loadPages;
    loadPages = async function () {
        try {
            const res = await fetch(`/api/documents/${DOC_ID}/text`);
            const data = await res.json();

            if (data.pages && data.pages.length > 0) {
                pages = data.pages;
            } else if (data.text) {
                pages = [data.text];
            } else {
                pages = ["No text content found."];
            }

            // Attempt resume
            loadProgress();

            renderPage();
            const controls = document.getElementById('pagination-controls');
            if (controls) controls.style.display = 'flex';
        } catch (e) {
            console.error(e);
            const contentDiv = document.getElementById('page-content');
            if (contentDiv) contentDiv.innerText = "Error loading text.";
        }
    }
</script>
{% endblock %}